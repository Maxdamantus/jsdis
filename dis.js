var test = "\u00c0\u000c\u0080\u0030\u0080\u0040\u0082\u00d0\u0080\u006e\u0014\u0008\u0001\u0000\u0006\u0008\u0040\u0000\u0000\u0010\u0011\u0051\u0001\u000a\u0028\u002d\u0011\u0000\u002c\u0055\u0009\u0028\u0030\u0060\u008a\u002c\u0030\u0009\u0072\u0089\u0030\u0028\u002c\u002d\u000d\u002c\u0030\u0000\u003a\u0011\u0001\u002c\u000d\u001a\u0003\u0005\u0011\u0004\u0030\u0029\u000d\u0028\u0030\u0020\u0004\u000a\u0030\u0027\u0005\u0011\u0002\u0034\u0029\u0005\u0004\u0034\u0020\u0027\u000d\u0030\u0034\u0010\u0009\u0048\u0000\u0034\u0010\u0005\u0011\u0004\u0034\u0029\u000d\u0028\u0034\u0020\u006f\u0055\u0005\u0000\u0034\u0020\u0004\u000a\u0034\u0027\u0005\u0011\u0002\u0030\u0029\u0005\u0004\u0030\u0020\u0027\u000d\u0034\u0030\u0010\u0009\u0048\u0000\u0030\u0010\u0005\u0011\u0004\u0034\u0055\u0009\u0028\u0030\u0029\u000d\u0028\u0034\u0020\u006f\u0095\u0030\u0001\u0034\u0020\u0004\u000a\u0034\u0027\u0005\u0011\u0002\u0030\u0029\u0005\u0004\u0030\u0020\u0027\u000d\u0034\u0030\u0010\u0009\u0048\u0000\u0030\u0010\u000c\u001b\u0072\u0089\u0034\u0020\u0024\u002d\u0029\u0034\u0000\u0030\u0018\u0011\u0000\u002c\u0018\u0009\u0030\u0028\u000c\u001b\u002d\u0011\u0000\u0024\u0055\u0009\u0020\u0028\u0060\u008a\u0024\u0028\u0033\u0005\u0011\u0003\u002c\u0029\u0005\u0008\u002c\u0020\u002d\u000d\u0024\u002c\u0024\u0072\u0089\u0030\u0020\u0024\u002d\u002d\u0030\u0000\u002c\u0028\u0027\u000d\u0028\u002c\u0010\u0009\u0048\u0000\u002c\u0010\u003a\u0011\u0001\u0024\u000d\u001a\u0028\u000c\u001b\u0072\u0089\u0030\u0020\u0024\u002d\u0029\u0030\u0000\u002c\u0072\u0089\u0030\u0020\u0024\u0072\u0089\u0034\u0020\u0028\u002d\u002d\u0034\u0000\u0030\u0000\u0072\u0089\u0034\u0020\u0028\u002d\u000d\u002c\u0034\u0000\u000c\u001b\u0055\u0009\u0020\u003c\u005e\u004a\u0002\u003c\u0080\u0048\u0072\u008a\u003c\u0020\u0001\u002d\u0029\u003c\u0000\u003c\u0072\u008a\u0080\u0040\u0020\u0000\u0060\u00aa\u003c\u0080\u0040\u0000\u0080\u006b\u0005\u0011\u0004\u0080\u0040\u0029\u000d\u0020\u0080\u0040\u0020\u002d\u0015\u0000\u0080\u0040\u0024\u002d\u0015\u0001\u0080\u0040\u0028\u0004\u000a\u0080\u0040\u0034\u000d\u001a\u0080\u006b\u0055\u0009\u0020\u0080\u0040\u0060\u004a\u0002\u0080\u0040\u0080\u006b\u002d\u0011\u0000\u0034\u002d\u0009\u0034\u0080\u0040\u0072\u0089\u0080\u0040\u0020\u0080\u0040\u002d\u0029\u0080\u0040\u0000\u0030\u002d\u0011\u0000\u002c\u0055\u0009\u0020\u0080\u0040\u0060\u008a\u002c\u0080\u0040\u0080\u005b\u0072\u0089\u0080\u0040\u0020\u002c\u0061\u00aa\u0030\u0080\u0040\u0000\u0080\u0059\u0005\u0011\u0004\u0080\u0040\u0029\u000d\u0020\u0080\u0040\u0020\u002d\u000d\u002c\u0080\u0040\u0024\u002d\u000d\u0034\u0080\u0040\u0028\u003a\u0011\u0001\u0034\u0004\u000a\u0080\u0040\u0034\u003a\u0011\u0001\u002c\u000d\u001a\u0080\u004f\u0013\u0059\u0000\u0028\u0005\u0011\u0007\u0080\u0040\u0029\u000d\u0020\u0080\u0040\u0020\u006f\u0095\u0030\u0000\u0080\u0040\u0020\u0029\u000d\u0028\u0080\u0040\u0024\u0006\u000a\u0080\u0040\u003c\u0005\u0011\u0007\u0080\u0040\u0055\u0009\u0020\u003c\u003a\u0091\u0030\u0001\u0038\u0029\u000d\u0020\u0080\u0040\u0020\u006f\u008d\u003c\u0038\u0080\u0040\u0020\u0029\u000d\u0028\u0080\u0040\u0024\u0006\u000a\u0080\u0040\u003c\u0019\u0009\u0028\u0038\u0019\u0009\u0028\u0038\u0029\u0001\u000c\u0028\u005d\u0082\u0024\u000c\u0080\u006d\u0018\u0011\u0000\u0024\u000c\u001b\u0000\u0014\u0001\u00f8\u0001\u0004\u0000\u0002\u0028\u0002\u0000\u0080\u0003\u0030\u0002\u0000\u0080\u0004\u0038\u0002\u0000\u0080\u0005\u0038\u0002\u0000\u00b0\u0006\u0038\u0002\u0000\u00e0\u0007\u0080\u0048\u0002\u0000\u00e0\u0034\u0000\u0024\u0053\u0079\u0073\u0032\u0004\u002d\u002d\u003a\u0008\u005b\u0025\u0064\u005d\u0020\u003d\u0020\u0025\u0064\u000a\u0000\u0052\u0061\u006e\u0064\u0054\u0065\u0073\u0074\u0000\u0000\u0006\u0042\u0044\u00b3\u0054\u0069\u006e\u0069\u0074\u0000\u0001\u0001\u00ac\u0084\u0090\u0033\u0070\u0072\u0069\u006e\u0074\u0000\u0000\u002f\u006a\u0073\u0064\u0069\u0073\u002f\u0052\u0061\u006e\u0064\u0054\u0065\u0073\u0074\u002e\u0062\u0000";

function showstuff(s){
	var r = "", i;

	if(typeof s == "object"){
		if(s instanceof Array){
			for(i = 0; i < s.length; i++)
				r += showstuff(s[i]) + ", ";
			return "[" + r + "]";
		}
		for(i in s)
			r += i + ": " + showstuff(s[i]) + ", ";
		return "{" + r + "}";
	}
	return s;
}

function replicate(n, f){
	var r = [];

	while(n-- > 0)
		r.push(f());
	return r;
}

var dis = function(){
	var builtin;

	function comp(i, n){
		return n == 32? i | 0 :
			n < 32? i < 1 << n-1? i : i - (1 << n) :
			i < Math.pow(2, n-1)? i : i - Math.pow(2, n);
	}

	function read(s){
		var i = 0;

		function byte(){
			return s.charCodeAt(i++);
		}

		function chunk(l){
			i += l;
			return s.substr(i - l, l);
		}

		function bigend32(){
			return byte() << 24 | byte() << 16 | byte() << 8 | byte();
		}

		function utf8(){
			var x = i;

			for(; s.charAt(i) != "\u0000"; i++);
			return s.substr(x, i++ - x);
		}

		// TODO: ieee754

		function header(){
			var r = {};
	
			r.magic = op();
			if(r.magic == 923426)
				r.signature = chunk(op());
			r.runtime_flag = op();
			r.stack_extent = op();
			r.code_size = op();
			r.data_size = op();
			r.type_size = op();
			r.link_size = op();
			r.entry_pc = op();
			r.entry_type = op();
			return r;
		}

		// operand = [] | [immed] | [ind, isfp] | [ind1, ind2, isfp]
		// [code, mid_operand, left_operand, right_operand]
		function instruction(){
			print("ins at " + i);
			var opcode = byte(), addrmode = byte(), amm, amsd, r, x;

			r = [opcode];
			amm = addrmode >> 6;
			amsd = [addrmode >> 3 & 7, addrmode & 7];
			r.push(
				amm == 0? [] :
				amm == 1? [op()] :
				[op(), !(amm & 1)]);
			for(x = 0; x < 2; x++)
				r.push(
					amsd[x] == 3 || amsd[x] > 5? [] :
					amsd[x] == 2? [op()] :
					amsd[x] >> 1? [op(), op(), amsd[x] & 1] :
					[op(), !!(amsd[x] & 1)]);
			return r;
		}

		function type(){
			var num = op(), size = op(), ptrs = op();

			return { desc_number: num, size: size, number_ptrs: ptrs,
				map: Array.prototype.map.call(chunk(ptrs), function(c){ return c.charCodeAt(0); }) };
		}

		function datum(){
			print("data at " + i.toString(16));
			var code = byte(), count, offset, s, t;

			count = code & 15? code & 15 : op();
			offset = op();
			if(code >> 4 == 7)
				return { type: 7, data: count };
			switch(code >> 4){
				case 1:
					return { type: "bytes", offset: offset, data: replicate(count, byte) };
				case 2:
					return { type: "words", offset: offset, data: replicate(count, bigend32) };
				case 3:
					// should I encode this into JS' UTF-16?
					return { type: "string", offset: offset, data: chunk(count) };
				case 4:
					return { type: "ieee754", offset: offset, data: replicate(count, ieee754) };
				case 5:
					return { type: "array", offset: offset, data: replicate(count, function(){
						return replicate(2, bigend32);
					}) };
				case 6:
					/* wtf */
					return { type: "index" };
				case 7:
					return { type: "pop", offset: offset, count: count };
				case 8:
					return { type: "longs", offset: offset, data: replicate(count, function(){
						return replicate(8, byte);
					}) };
			}
		}

		function link(){
			return { pc: op(), type: op(), sig: bigend32(), name: utf8() };
		}

		function moduleimport(){
			function functionimport(){
				print("functionimport @ " + i.toString(16));
				return { sig: bigend32(), name: utf8() };
			}

			var t = replicate(op(), functionimport);
			print("moduleimport() = " + showstuff(t));
			return t;
		}

		function all(){
			var code, types, data = [], name, links, imports, head = header(), x;

			code = replicate(head.code_size, instruction);
			types = replicate(head.type_size, type);
			while(byte()){
				i--;
				data.push(datum());
			}
			name = utf8();
			links = replicate(head.link_size, link);
			imports = replicate(op(), moduleimport);
			print("read all: " + i.toString(16));
			return { name: name, header: head, code: code, types: types, data: data, links: links, imports: imports };
		}
	
		function op(){
			var b = byte();

			if((b & 128) == 0)
				return comp(b & 127, 7);
			if((b & (128 | 64)) == 128)
				return comp((b & 63) << 8 | byte(), 14);
			return comp((b & 63) << 24 | byte() << 16 | byte() << 8 | byte(), 30);
		}

		return all();
	}

	function quotes(s){
		// TODO: ..
		return s.toSource();
	}

	function makemp(data){
		var mp = [], ins, x, y;

		for(x = 0; x < data.length; x++)
			switch((ins = data[x]).type){
				case "bytes":
				case "words":
					m = ins.type == "words"? 4 : 1;
					for(y = 0; y < ins.data.length; y++)
						mp[ins.offset + y*m] = ins.data[y];
					break;
				case "string":
					mp[ins.offset] = ins.data;
					break;
				case "ieee754":
					// TODO: ..
					break;
				case "array":
					for(y = 0; y < ins.data.length; y++)
						mp[ins.offset + y*4] = [0, ins.data[1], []];
					break;
				case "set":
					// TODO: ?!#
					break;
				case "pop":
					// TODO: ?!#
					break;
				case "longs":
					// TODO: 0xff << 24 < 0
					for(y = 0; y < ins.data.length; y++)
						mp[ins.offset + y*8] = [
							ins.data[y][4] << 24 | ins.data[y][5] << 16 | ins.data[y][6] << 8 | ins.data[y][7],
							ins.data[y][0] << 24 | ins.data[y][1] << 16 | ins.data[y][2] << 8 | ins.data[y][3]];
			}
		print("mp = " + mp.toSource());
		return mp;
	}

	function insc(s, p, c){
		return s.substr(0, p) + String.fromCharCode(c) + s.substr(p + 1);
	}

	var procs = [];

	function start(module){
		procs.push(function(){
			return module([{ name: "init", sig: 0x4244b354 }])[0]([0,[]]);
		});
	}

	// keep calling this until it returns 0
	function run(){
		var r, n;

		if(procs.length > 0)
			if(r = procs[n = Math.random()*procs.length | 0]())
				procs[n] = r;
			else
				rem(procs, n);
		return procs.length;
	}

	function rem(arr, n){
		if(n == arr.length - 1)
			arr.pop();
		else
			arr[n] = arr.pop();
	}

	function runall(){
		while(run() > 0);
	}

	function spawner(fun){
		return procs.push(fun) - 1;
	}

	function channel(){
		var receivers = [], senders = [];

		function recv(ptr, cont){
			var n;

			if(senders.length > 0){
				ptr[1][ptr[0]] = senders[n = Math.random()*senders.length | 0][0];
				procs.push(senders[n][1]);
				if(cont)
					procs.push(cont);
				rem(senders, n);
			}else
				receivers.push([ptr, cont]);
		}

		function send(val, cont){
			var n, ptr;

			if(receivers.length > 0){
				ptr = receivers[n = Math.random()*receivers.length | 0][0];
				ptr[1][ptr[0]] = val;
				procs.push(receivers[n][1]);
				if(cont)
					procs.push(cont);
				rem(receivers, n);
			}else
				senders.push([val, cont]);
		}

		return [send, recv];
	}

	// loader :: (string, [importing]) -> [exporting]
	function loader(name, imports){
		if(name[0] == "$")
			return builtin[name.substr(1)](imports);
		// wonder what will go here
	}

	function exporter(importing, exporting, main){
		var r = [], x, y;

		for(x = 0; x < importing.length; x++)
			for(y = 0; y < exporting.length; y++){
				if(importing[x].name == exporting[y].name && importing[x].sig == exporting[y].sig){
					print("exporter matched " + importing[x].name);
					r[x] = function(pc){
						return function(fp, ret){
							return main([false, [0, []], pc], ret);
						};
					}(exporting[y].pc);
					break;
				}
				throw "module has no export (" + importing[x].name + ", " + importing[x].sig.toString(16) + ")";
			}
		return r;
	}

	function getargs(fp){
		var x = 32;
		
		function get(sz){
			return function(){
				for(; x % sz; x++);
				x += sz;
				return fp[1][fp[0] + x - sz];
			};
		}

		return {
			word: get(4),
			byte: get(1),
			dword: get(8),
		};
	}

	function pointer(base, offs){
		return {
			base: base, offs: offs,

			toString: function(){
				return base + "[1][" + base + "[0] + " + offs + "]";
			},

			addrof: function(){
				return "[" + offs + " + " + base + "[0], " + base + "[1]]"
			}
		};
	}

	// module interface:
	//  module = ([importing]) -> [exporting]
	//  importing = { name: string, sig: int }
	//  exporting = (frame /* fp for the call */, return /* returned after fibre's last ret */) -> exporting
	//  return = () -> exporting
	// the exporting function returns a continuation
	// inter-module calls use exporting functions

	function compile(source){
		function operand(ins, i, addrof){
			var n = ins[i + 1], j;
			switch(n.length){
				case 0:
					if(i == 0)
						return operand(ins, 2);
					throw "expected operand";
				case 1:
					if(addrof)
						throw "address of immediate";
					return "" + n[0];
				case 2:
					j = pointer(n[1]? "fp" : "mp", n[0]);
					return addrof? j.addrof() : j.toString();
					i = n[1]? "fp" : "mp";
					return addrof? "[" + n[0] + " + " + i + "[0], " + i + "[1]]" : i + "[1][" + i + "[0] + " + n[0] + "]";
				case 3:
					j = pointer(n[2]? "fp" : "mp", n[0]);
					j = pointer(j, n[1]);
					return addrof? j.addrof() : j.toString();
					j = n[2]? "fp" : "mp";
					i = j + "[1][" + j + "[0] + " + n[0] + "]";
					return addrof? "[" + j + "[0] + " + n[1] + ", " + j + "[1]]" :
						i + "[1][" + n[1] + " + " + i + "[0]]";
//					return (n[2]? "fp" : "mp") + "[" + n[0] + "][" + n[1] + "]";
			}
		}

		var code = [], x, y, m, ins;
		
		code.push("return function(importing){");
		code.push("var mp = [0, newmp()], tmp, tmq, tmr;");
		code.push("function main(fps, ret){");
		code.push(" var fp = fps[1], pc = fps[2], ic;");
		code.push(" for(ic = 0; ic++ < 10000;) switch(pc){");
		for(x = 0; x < source.code.length; x++){
			code.push("  case " + x + ":");
			print("ins = " + showstuff(source.code[x]));
			switch((ins = source.code[x])[0]){
				case 0x00: // nop
					break;
				case 0x04: // call
					code.push("   fps[2] = " + (x + 1) + ";");
					code.push("   fps = [fps, fp = " + operand(ins, 1) + ", pc = " + operand(ins, 2) + "];");
					code.push("   break;");
					break;
				case 0x05: // frame
					code.push("   " + operand(ins, 2) + " = [0, []];");
					break;
				case 0x06: // spawn
					code.push("   void function(nfps){");
					code.push("    spawner(function(){");
					code.push("     return main(nfps);");
					code.push("    });");
					code.push("   }([false, " + operand(ins, 1) + ", " + operand(ins, 2) + "]);");
					break;
				case 0x08: // load
					code.push("   " + operand(ins, 2) + " = loader(" + operand(ins, 1) + ", imports[" + operand(ins, 0) + "]);");
					break;
				case 0x09: // mcall
					code.push("   fps[2] = " + (x + 1) + ";");
					code.push("   return function(n, f){");
					code.push("     return function(){");
					code.push("       return n(f, function(){");
					code.push("         return main(fps, ret);");
					code.push("       });");
					code.push("     };");
					code.push("   }(" + operand(ins, 2) + "[" + operand(ins, 0) + "], " + operand(ins, 1) + ");");
					break;
				case 0x0c: // ret
					code.push("   if(!(fps = fps[0]))");
					code.push("    return ret;");
					code.push("   fp = fps[1];");
					code.push("   pc = fps[2];");
					code.push("   break;");
					break;
				case 0x0d: // jmp
					code.push("   pc = " + operand(ins, 2) + ";");
					code.push("   break;");
					break;
				case 0x11: // newa
					code.push("   " + operand(ins, 2) + " = [0, " + operand(ins, 1) + ", []];");
					break;
				case 0x12: // newcb
				case 0x13: // newcw
				case 0x14: // newcf
				case 0x15: // newcp
				case 0x16: // newcm
				case 0x17: // newcmp
				case 0x8f: // newcl
					code.push("   " + operand(ins, 2) + " = channel();");
					break;
				case 0x18: // send
					code.push("   fps[2] = " + (x + 1) + ";");
					code.push("   " + operand(ins, 2) + "[0](" + operand(ins, 1) + ", function(){");
					code.push("    return main(fps, ret);");
					code.push("   });");
					code.push("   return;");
					break;
				case 0x19: // recv
					code.push("   fps[2] = " + (x + 1) + ";");
					code.push("   " + operand(ins, 1) + "[1](" + operand(ins, 2, true) + ", function(){");
					code.push("    return main(fps, ret);");
					code.push("   });");
					code.push("   return;");
					break;
				case 0x27: // lea
					code.push("   " + operand(ins, 2) + " = " + operand(ins, 1, true) + ";");
					break;
				// the following seems weird .. documentation suggests
				// indw, etc grab the value from the array; behaviour
				// suggests it grabs the address, like indx
				case 0x28: // indx
				case 0x52: // indc
				case 0x72: // indw
				case 0x73: // indf
				case 0x74: // indb
				case 0x91: // indl
				// TODO: multiply index by element size .. maybe
					code.push("   tmp = " + operand(ins, 1) + ";");
					code.push("   " + operand(ins, 0) + " = [tmp[0] + " + operand(ins, 2) + ", tmp[2]];");
					break;
				case 0x29: // movp
				case 0x2a: // movm
				case 0x2b: // movmp
				case 0x2c: // movb
				case 0x2d: // movw
				case 0x2e: // movf
				case 0x76: // movl
					code.push("   " + operand(ins, 2) + " = " + operand(ins, 1) + ";");
					break;
				case 0x3a: // addw
				case 0x53: // addc
				case 0x39: // addb
				case 0x3b: // addf
					code.push("   " + operand(ins, 2) + " = " + operand(ins, 1) + " + " + operand(ins, 0) + ";"); 
					break;
				case 0x77: // addl
					// TODO: check logic .. negatives?
					code.push("   tmp = (" + operand(ins, 1) + "[0] + " + operand(ins, 0) + "[0]) % 0x100000000;");
					code.push("   " + operand(ins, 2) + " = [tmp, (tmp < " + operand(ins, 1) + "[0]? 1 : 0) + " +
							operand(ins, 1) + "[1] + " + operand(ins, 0) + "[1]];");
					break;
				case 0x51: // insc
					code.push("   " + operand(ins, 2) + " = insc(" + operand(ins, 2) + ", " + operand(ins, 0) + ", " + operand(ins, 1) + ");"); 
					break;
				case 0x5a: // bleb
				case 0x60: // blew
				case 0x66: // blef
				case 0x6c: // blec
				case 0x83: // blel
				case 0x62: // bgew
				case 0x85: // bgel
				case 0x68: // bgef
				case 0x6e: // bgec
				case 0x5c: // bgeb
				case 0x61: // bgtw
				case 0x84: // bgtl
				case 0x67: // bgtf
				case 0x6d: // bgtc
				case 0x5b: // bgtb
					// TODO: handle blel
					code.push("   if(" + operand(ins, 1) + " " + 
						([0x5a, 0x60, 0x66, 0x6c, 0x83].indexOf(ins[0]) >= 0? "<=" :
						[0x62, 0x85, 0x68, 0x6e, 0x5c].indexOf(ins[0]) >= 0? ">=" :
						">") +
						" " + operand(ins, 0) + "){");
					code.push("    pc = " + operand(ins, 2) + ";");
					code.push("    break;");
					code.push("   }");
					break;
				case 0x55: // lena
					code.push("   " + operand(ins, 2) + " = " + operand(ins, 1) + "[1];");
					break;
				case 0x63: // beqf
				case 0x86: // beql
				case 0x69: // beqc
				case 0x57: // beqb
				case 0x5d: // beqw
					if(ins[0] == 0x86) // blel
						code.push("   if(" + operand(ins, 1) + "[0] == " + operand(ins, 0) + "[0] && " +
								operand(ins, 1) + "[1] == " + operand(ins, 0) + "[1]){");
					else
						code.push("   if(" + operand(ins, 1) + " == " + operand(ins, 0) + "){");
					code.push("    pc = " + operand(ins, 2) + ";");
					code.push("    break;");
					code.push("   }");
					break;
				case 0x6f: // slicea
					code.push("   tmp = " + operand(ins, 2) + ";");
					code.push("   tmq = " + operand(ins, 1) + ";");
					code.push("   " + operand(ins, 2) + " = [tmp[0] + tmq, " + operand(ins, 0) + " - tmq, tmp[2]];");
					break;
				default:
					code.push("   // unknown instruction: " + ins[0].toString(16));
			}
		}
		code.push("  default:");
		code.push("   throw \"pc out of bounds\";");
		code.push(" }");
		code.push("fps[2] = 0;");
		code.push("return function(){ return main(fps, ret); };");
		code.push("}");
		code.push("return exporter(importing, exports, main);");
		code.push("}");
		//return code.join("\n");
		print(code.join("\n"));
		return Function("exports", "entry", "imports", "exporter", "loader", "spawner", "channel", "insc", "newmp", code.join("\n"))(
			source.links,
			source.entry_pc,
			source.imports,
			exporter,
			loader,
			spawner,
			channel,
			insc,
			function(data){ // trying not to keep a reference to `source`
				return function newmp(){
					return makemp(data);
				};
			}(source.data));
	}

	builtin = {
		Sys: function(importing){
			var x, ret = [];

			for(x = 0; x < importing.length; x++)
				if(importing[x].name == "print" && importing[x].sig == comp(0xac849033, 32))
					ret[x] = function(fp, cont){
				//		print("fp = " + fp.toSource());
						print("sys->print: " + printx(getargs(fp)));
						return cont;
					};
				else
					throw "requested invalid export (" + importing[x].name + ", " + importing[x].sig + ") from $Sys";
			return ret;
		}
	};

	function printx(args){
		var fmt = args.word(), p, c, done, isbig, out = [];

		for(p = 0; (c = fmt.indexOf("%", p)) >= 0; p = c){
			out.push(fmt.substr(p, c - p));
			isbig = false;
			for(done = false; !done && c < fmt.length;)
				switch(fmt[++c]){
					case "s":
						out.push(args.word());
						done = true;
						break;
					case "d":
						if(isbig)
							out.push(args.dword()); // TODO: ..
						else
							out.push(args.word() | 0);
						done = true;
						break;
					case "b":
						isbig = true;
						break;
					case "%":
						out.push("%");
						done = true;
						break;
				}
			c++;
		}
		out.push(fmt.substr(p));
		return out.join("");
	}

	var t;
	print(showstuff(t = read(test)));
	/*print*/(showstuff(t = compile(t)));
	start(t);
	runall();
}();
